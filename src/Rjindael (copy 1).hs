{-# LANGUAGE OverloadedStrings #-}
module Rjindael where

import qualified Data.ByteString as BS
import qualified Data.Bits as B
import GaloisFields
import Data.Bits ((.&.),(.|.),xor)
import Numeric (showHex,showIntAtBase)
import Data.Char (intToDigit)
import Data.Word
import Data.Bits.ByteString
import Data.List.Split (chunksOf)
import qualified Data.Matrix as Mat

nb = 4 :: Int
nk = 4 :: Int
nr_128 = 10 :: Int
nr_192 = 12 :: Int
nr_256 = 14 :: Int

aes_mod = aes_GF2_mod

          
gf2_8_a = [3,1,1,2]

multParts :: Int -> Int -> Int -> [Int]
multParts n a b 
  | n > a     = []
  | otherwise = (n .&. a) * b : multParts (B.shiftL n 1) a b

rotateByteStringL :: Int -> BS.ByteString -> BS.ByteString
rotateByteStringL i bs = BS.append (BS.drop i bs) (BS.take i bs)

rconMod :: BS.ByteString
rconMod = BS.pack $ [1,27]

rconModInt :: Int
rconModInt = 0x11b

testin = "abcdefghijklmnop" :: BS.ByteString

inputToStateMatrix :: BS.ByteString -> Mat.Matrix Word8
inputToStateMatrix bs = Mat.fromList 4 4 $ BS.unpack bs

stateMatrixToOutput :: Mat.Matrix Word8 -> BS.ByteString
stateMatrixToOutput mat = BS.pack $ Mat.toList mat

rconTable :: [Word8]
rconTable = [ 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40
            , 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a
            , 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a
            , 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39 
            , 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25
            , 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a
            , 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08
            , 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8 
            , 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6
            , 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef
            , 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61
            , 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc 
            , 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01
            , 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b 
            , 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e
            , 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3 
            , 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4
            , 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94 
            , 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8
            , 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20 
            , 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d
            , 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35 
            , 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91
            , 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f 
            , 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d
            , 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04 
            , 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c
            , 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63 
            , 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa
            , 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd 
            , 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66
            , 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d]

addRoundKey :: Mat.Matrix Word8 -> [Word8] -> Mat.Matrix Word8
addRoundKey a b = Mat.elementWise xor a b


subBytes :: Mat.Matrix Word8 -> Mat.Matrix Word8
subBytes a = fmap subByte a


subByte :: Word8 -> Word8
subByte b' = b `xor` b4 `xor` b5 `xor` b6 `xor` b7 `xor` c
  where
    b = gf2Inv b'
    b4 = B.rotateR b 4
    b5 = B.rotateR b 5
    b6 = B.rotateR b 6
    b7 = B.rotateR b 7

c :: Word8
c = 0x63

rotateList :: Int -> [a] -> [a]
rotateList _ [] = []
rotateList n xs = zipWith const (drop n (cycle xs)) xs

           
shiftRows :: Mat.Matrix Word8 -> Mat.Matrix Word8
shiftRows m = Mat.fromLists . zipWith rotateList [0..3] $ Mat.toLists m
             
mixColumn :: [Word8] -> [Word8]
mixColumn [s0,s1,s2,s3] = [s0', s1', s2', s3']
  where
    s0' = 0x2 .*. s0  .+. 0x3 .*. s1  .+. s2  .+. s3
    s1' = s0  .+. 0x2 .*. s1  .+. 0x3 .*. s2  .+. s3
    s2' = s0  .+. s1  .+. 0x2 .*. s2  .+. 0x3 .*. s3
    s3' = 0x3 .*. s0  .+. s1  .+. s2  .+. 0x2 .*. s3

mixColumns :: Mat.Matrix Word8 -> Mat.Matrix Word8
mixColumns m = Mat.transpose . Mat.fromLists . map mixColumn
              . Mat.toLists . Mat.transpose $ m

hexMatrix :: Mat.Matrix Word8 -> Mat.Matrix String
hexMatrix = fmap (\a -> showHex a "")
                
testInput :: BS.ByteString
testInput = "abcdefghijklmnop"

cipher a = inputToStateMatrix a

tstate :: Mat.Matrix Word8
tstate = Mat.fromLists [[0x19,0xa0,0x9a,0xe9],
                        [0x3d,0xf4,0xc6,0xf8],
                        [0xe3,0xe2,0x8d,0x48],
                        [0xbe,0x2b,0x2a,0x08]]

keyExpansion :: [Word8] -> Int -> [[Word8]]
keyExpansion key nk =
    where w = chunksOf 4 key
